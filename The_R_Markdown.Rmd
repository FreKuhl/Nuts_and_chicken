---
title: "Nuts and chicken"
author: "Lukas Gürtler & Frederik Kuhl"
output: html_document
bibliography: 
  - bib/references.bib 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(decisionSupport)
library(tidyverse)
library(knitr)
library(readxl)
library(rmarkdown)
```

```{r add_R_bib, include=FALSE}
knitr::write_bib(c(.packages(),
                   'knitr', 'decisionSupport'), 'bib/packages.bib')
```


This supplementary is available under <https://github.com/FreKuhl/Nuts_and_chicken.git> and outlines the Decision Analysis model we created in the ['Decision Analysis and Forecasting for Agricultural Development'](https://cory-whitney.shinyapps.io/Decision_Analysis_Course/) course by [Cory Whitney](https://cory-whitney.com/) & [Eike Lüdeling](https://eikeluedeling.com/index.html) at the University of Bonn in the Corona Summer of 2021. 

The idea behind our model, was to create an Agroforestry intervention for a small farmland plot in the Eifel region. The plot that is used for regular crops right now, is going to be used to sequestrate CO2. As the land use plan doesn't allow planting a regular forest we looked for different solutions to combine trees with different animals. The best solution for the owners [Woodify](woodify.de) was planting trees and keeping chicken in a chicken mobile house. So we came up with five different scenarios that have different levels of intensity. The way we calculated the different outcomes can be seen in our conceptual model below.

## Input table
The input table `Input_estimates.xlsx` (attached) contains: Variable names, unit, distributions (posnorm = positive normal distribution, const = constant, tnorm_0_1= truncated normal distribution, norm = normal distribution), lower bound, mean, upper bound and definition of variables. The sources of information can also be found within the excel sheet.

## Implementing the model in R
Here we provide our mathematical model that enables simulation of decision outcomes.
The calculations in this document are based on random draws from the distributions in the input table `Input_estimates.xlsx`. Explanations for code chunks are not part of the actual simulation. 

Load the input table `Input_estimates.xlsx` and make variables.
```{r eval= FALSE}
input_estimates <- read_excel("input_estimates.xlsx")

make_variables <- function(est,n=1)
{ x <- random(rho=est, n=n)
for(i in colnames(x)) assign(i, as.numeric(x[1,i]),envir = .GlobalEnv)}

make_variables(as.estimate(input_estimates))
```

We generated a function called `model_function` to evaluate the decision options in `decisionSupport` [@luedeling_decisionsupport_2021]. The following calculations are part of this function (see the entire function in `model-final.R`). 
```{r eval= FALSE}
model_function <- function() {}
```
In the following sections we left out some repetitive parts of the code for easier reading.

## The Scenarios
The investments and risks that are made independently of the scenarios have been grouped together under #General. This variables are the variance of nut prices, the cance of losses due to frost, the amount of subsidies, the initial planting of grass and setting up and maintaining fences. 
```{r eval= FALSE}
# General ----
  
  full_yield_period <- years - 8
  
  nuts_frost <- chance_event(
    chance = late_frost,
    value_if = 0.3,
    value_if_not = 1,
    n = years)
  
  nut_price <- vv(var_mean = nut_price,
                  var_CV = 20,
                  n = years)
  
  subsidies_vec <- vv(var_mean = subsidies,
                  var_CV = 1,
                  n = years)
  
  general_investments_vec <- vv(var_mean = maintaining_fences_cost,
                                var_CV = 30,
                                n = years)
  
  ###
  general_investments_vec[1] <- general_investments_vec[1] + 
    grass_planting_cost + initial_fences_cost
```    
    
### The baseline scenario
The baseline scenario describes the current situation on the plot and is used to compare the different decisions with the current state. The plot is used as arable land and its income consists of a crop rotation with different cultures. The income in the different years varies annually, as in the other scenarios. The different cultures are winterbarley, rye, wheat and summerbarley. They are all calculated like the example below and added up over the period of 30 years into vectors for each model run.
```{r eval= FALSE}
 winterbarley_yield_vec <- vv(var_mean = winterbarley_yield,
                               var_CV = 10,
                               n = years)
  winterbarley_costs_vec <- vv(var_mean = winterbarley_costs,
                               var_CV = 5,
                               n = years)
  winterbarley_work_vec <- vv(var_mean = winterbarley_work,
                              var_CV = 5,
                              n = years)
  winterbarley_price_vec <- vv(var_mean = winterbarley_price,
                               var_CV = 10,
                               n = years)
  
  winterbarley_income_vec <- (winterbarley_yield_vec * winterbarley_price_vec) -
    (winterbarley_costs_vec + (winterbarley_work_vec * working_hours_costs))
```

### Scenario 1
Scenario 1 consists of a hazelnut plantation with 70 trees spaced in rows of 10 meters. The plantation is irrigated with a drip system and additionally hay is produced between the rows of trees. In addition to the plantation, 200 chickens are kept with a chicken mobile. 

For each branch of the income we calculated the yields and the cost. The Code below shows this for the Nuts yield of scenario 1 and 4. 
Using the `gompertz_yield` function the nuts yield starts after 6 years and the first full yield can be expected after 10 years. Also the possibility of frost damage is applied by multypling the vectors.
```{r eval= FALSE}
 # Yield Nuts ----
  # For Versions 1 and 4

nuts_1 <- gompertz_yield(
    max_harvest = nut_yield_1,
    time_to_first_yield_estimate = 6,
    first_yield_estimate_percent = 40,
    time_to_second_yield_estimate = 10,
    second_yield_estimate_percent = 100,
    n_years = years,
    var_CV = 10)
  
  nuts_yield_vec_1 <- nuts_1 * nuts_frost
  
  harvest_count_1 <- ifelse(nuts_yield_vec_1 < 20, 0, 1)
```
The hay production is implemented with varying amounts.
```{r eval= FALSE}
  amount_bales <- vv(var_mean = amount_bales_1,
                     var_CV = 10,
                     n = years)
  
  income_per_bale <- vv(var_mean = income_bale_1,
                        var_CV = 10,
                        n = years)
  
  income_hay <- amount_bales * income_per_bale
```
The final income vector for nut production with the added income by hay for scenario 1 & 4.
```{r eval= FALSE}
  ###
  nut_income_vec_1_4 <- (nuts_yield_vec_1 * nut_price) + income_hay
```
Then we calculated the costs for the nut plantation.
```{r eval= FALSE}
  # Nuts Costs ----
  # For Versions 1 and 4
  
  maintaining_tree_h_vec_1 <- vv(var_mean = maintaining_trees_h_1,
                                 var_CV = 15,
                                 n = years)
  
  maintaining_tree_h_vec_1[8:full_yield_period] <- 
    maintaining_tree_h_vec_1[8:full_yield_period] * maintaining_trees_factor
  
  nut_harvest_h_vec_1 <- vv(var_mean = nut_harvest_hours_1,
                            var_CV = 5,
                            n = years)
  
  nut_harvest_h_vec_1 <- nut_harvest_h_vec_1 * harvest_count_1
  
  nut_mulch_h_vec_1 <- vv(var_mean = mulch_h_1,
                          var_CV = 5,
                          n = years)
  
  other_nut_h_1 <- vv(var_mean = other_nut_h_1,
                      var_CV = 5,
                      n = years)
  
  nut_h_vec_1 <- maintaining_tree_h_vec_1 + nut_harvest_h_vec_1 + 
    nut_mulch_h_vec_1 + other_nut_h_1
  
  nut_h_vec_1[1] <- nut_h_vec_1[1] + tree_planting_hours_1
  
  nut_workcosts_vec_1 <- nut_h_vec_1 * working_hours_costs
  
  nut_other_costs_vec_1 <- vv(var_mean = nut_var_costs_1,
                              var_CV = 20,
                              n = years)
  
  nut_other_costs_vec_1[1] <- nut_other_costs_vec_1[1] + tree_planting_costs_1
  
  harvest_nets_1 <- vv(var_mean = harvest_nets_1,
                       var_CV = 1,
                       n = years)
```
The costs are then stored in vectors.
```{r eval= FALSE}
  harvest_nets_1[] <- harvest_nets_1 *
    c(TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE)
 
  nut_other_costs_vec_1 <- nut_other_costs_vec_1 + harvest_nets_1
  
  nut_other_costs_vec_1[1] <- nut_other_costs_vec_1[1] + tree_planting_costs_1
  
  nut_other_costs_vec_4 <- nut_other_costs_vec_1
  
  nut_other_costs_vec_4[1] <- 
    nut_other_costs_vec_4[1] + truffle_tree_planting_costs_1
  
  hay_costs <- vv(var_mean = hay_costs_1,
                  var_CV = 5,
                  n = years)
```
The `chance_event` of having to replace trees because of damage is added.
```{r eval= FALSE}
  replace_trees_1 <- chance_event(chance = 0.1,
                                  value_if = 3,
                                  value_if_not = 0,
                                  n = years,
                                  CV_if = 30)
  
  replace_trees_1 <- replace_trees_1 * replacing_trees_cost
  
  replace_trees_4 <- replace_trees_1 * replacing_truffle_trees_cost
```

### Scenario 2
Scenario 2 consists of a hazelnut plantation with 200 trees, which stand at a distance of 5 meters, this is irrigated by a drip system and also here 200 chickens are kept with a chicken mobile. 

As all the plantations in our model are irrigated the code below shows the calculation for irrigation in scenario 2 and 5.
We assumed that the number of days in which irrigation is required does not exceed two months. In each run, numbers between 10 and 55 are randomly selected.
```{r eval= FALSE}
 # Irrigation ----
  
  days_irrigation <- vv(var_mean = days_to_irrigate,
                        var_CV = 60,
                        n = years)
  
  days_irrigation[days_irrigation < 10] <- 10
  
  days_irrigation[days_irrigation > 55] <- 55
  
  irrigation_h_vec <- days_irrigation * work_per_irrigation
```

```{r eval= FALSE}
  # For Versions 2 and 5
  
  irrigation_installation_2 <- water_trailer + installation_irrigation_2
  
  water_usage_vec_2 <- days_irrigation * water_per_day_2
  
  trailer_refills_vec_2 <- water_usage_vec_2 / trailer_capacity
  
  trailer_refills_vec_2 <- trailer_refills_vec_2 + 3
  
  refill_h_vec_2 <- trailer_refills_vec_2 * work_per_trailer
  
  irrigation_h_vec_2 <- refill_h_vec_2 + irrigation_h_vec
  
  irrigation_costs_2 <- irrigation_h_vec_2 * working_hours_costs
  
  maintaining_irrigation_2 <- vv(var_mean = maintaining_irrigation_2,
                                 var_CV = 10,
                                 n = years)
  
  water_costs_2 <- water_usage_vec_2 * water_price
  
  irrigation_costs_2_5 <- 
    irrigation_costs_2 + maintaining_irrigation_2 + water_costs_2
  
  ###
  irrigation_costs_2_5[1] <- irrigation_costs_2_5[1] + irrigation_installation_2
```

### Scenario 3
Scenario 3 consists of 200 trees of different species, which are additionally infected with truffles and are not to be harvested. Also here 200 chickens are kept with a chicken mobile. As there is no nut harvest in this scenario we used a different way of calculating the cost for maintenance.
```{r eval= FALSE}
# Version 3
  
  maintaining_tree_h_vec_3 <- vv(var_mean = maintaining_trees_h_3,
                                 var_CV = 15,
                                 n = years)
  
  nut_mulch_h_vec_3 <- vv(var_mean = mulch_h_3,
                          var_CV = 5,
                          n = years)
  
  tree_h_vec <- maintaining_tree_h_vec_3 + nut_mulch_h_vec_3
  
  tree_h_vec[1] <- tree_h_vec[1] + tree_planting_hours_3
  
  tree_other_costs_vec <- vv(var_mean = tree_var_costs,
                             var_CV = 20,
                             n = years)
  
  tree_other_costs_vec[1] <- tree_other_costs_vec[1] + tree_planting_costs_3
```

In this scenario the irrigation is done by a trailer that needs to be refilled and is manually driven over the meadow.
```{r eval= FALSE}
# Truffle irrigation for 3
  
  days_irrigation_truffle <- vv(var_mean = truffle_days_to_irrigate,
                        var_CV = 60,
                        n = years)
  
  days_irrigation_truffle[days_irrigation_truffle < 20] <- 20
  
  days_irrigation_truffle[days_irrigation_truffle > 70] <- 70
  
  
  truffle_irrigation_h_vec <- days_irrigation_truffle * work_per_irrigation
  
  water_usage_vec_truffle <- days_irrigation_truffle * truffle_water_per_day
  
  trailer_refills_vec_truffle <- water_usage_vec_truffle / trailer_capacity
  
  trailer_refills_vec_truffle <- trailer_refills_vec_truffle + 3
  
  refill_h_vec_truffle <- trailer_refills_vec_truffle * work_per_trailer
  
  irrigation_h_vec_truffle <- refill_h_vec_truffle + truffle_irrigation_h_vec
  
  irrigation_costs_truffle <- irrigation_h_vec_truffle * working_hours_costs
  
  maintaining_irrigation_truffle <- vv(var_mean = maintaining_irrigation_2,
                                 var_CV = 10,
                                 n = years)
  
  water_costs_truffle <- water_usage_vec_truffle * water_price
  
  irrigation_costs_truffle <- 
    irrigation_costs_truffle + maintaining_irrigation_truffle + water_costs_truffle
  
  irrigation_costs_truffle[1] <- 
    irrigation_costs_truffle[1] + irrigation_installation_2
```
The final truffle vector is added.
```{r eval= FALSE}
  ###
  truffle_final_vec_3 <- 
    truffle_income - truffle_harvest_costs - irrigation_costs_truffle
  ###
```

### Scenario 4
Scenario 4 is exactly the same as scenario 1, but the trees are additionally infected with truffles. The code below shows the way truffle yield and income are calculated in scenario 3, 4 and 5.
```{r eval= FALSE}
  truffle <- gompertz_yield(
    max_harvest = truffle_yield,
    time_to_first_yield_estimate = 5,
    first_yield_estimate_percent = 10,
    time_to_second_yield_estimate = 15,
    second_yield_estimate_percent = 100,
    n_years = years,
    var_CV = 60,
  )
  
  truffle_price <- vv(var_mean = truffle_price,
                      var_CV = 10,
                      n = years)
  
  truffle_income <- truffle * truffle_price
  
  truffle_harvest_costs <- vv(var_mean = truffle_harvest_costs,
                              var_CV = 5,
                              n = years)
  
  truffle_harvest_costs[1:5] <- 0
```
The final vector for scenario 4 & 5 is created it will later be reduced for scenario 4 account for the smaller number of trees.
```{r eval= FALSE}
  ###
  truffle_final_vec_4_5 <- truffle_income - truffle_harvest_costs
  ###
```

### Scenario 5
Scenario 5 is exactly the same as scenario 2, but the trees are additionally infected with truffles.

The income generated by chicken eggs is the same in all the scenarios. We added two different versions, one with 50 and one with 200 chicken because the egg production also adds a lot of CO2 and we wanted to see the impact depending on the amount of chicken.
```{r eval= FALSE}
# Chicken ----
  # For Version 1, 2, 3, 4 and 5
  
  if (number_of_chicken == 50){
    
    initial_chicken_costs_final_2 <-
      (number_of_chicken * chicken_replacement_cost) + initial_chicken_mobile_cost_2
    
    maintaining_chicken_mobile_vec <- vv(var_mean = maintaining_chicken_mobile_2,
                                           var_CV = 15,
                                           n = years)
    
    maintaining_chicken_mobile_vec[1] <-
      maintaining_chicken_mobile_vec[1] + initial_chicken_costs_final_2
    
    working_hours_chicken <- vv(var_mean = working_hours_chicken_2,
                                var_CV = 10,
                                n = years)
```
The structure for both versions is the same just the numbers vary.
```{r eval= FALSE}
  } else if (number_of_chicken == 200) {
    
    initial_chicken_costs_final_1 <-
      (number_of_chicken * chicken_replacement_cost) + initial_chicken_mobile_cost_1
    
    maintaining_chicken_mobile_vec <- vv(var_mean = maintaining_chicken_mobile_1,
                                           var_CV = 15,
                                           n = years)
    
    maintaining_chicken_mobile_vec[1] <-
      maintaining_chicken_mobile_vec[1] + initial_chicken_costs_final_1
    
    working_hours_chicken <- vv(var_mean = working_hours_chicken_1,
                                var_CV = 10,
                                n = years)
```
If the `numer_of_chicken` is not 50 or 200 a error message is given.
```{r eval= FALSE}
  } else {
    print("Number of chicken wrong")
  }
```
The cost for feed and the working cost vector are added.
```{r eval= FALSE}
  chicken_feed_vec <- vv(var_mean = feed_per_hen,
                     var_CV = 5,
                     n = years)
  
  feed_cost_vec <- vv(var_mean = feed_cost,
                  var_CV = 10,
                  n = years)
  
  feed_cost_final_vec <- number_of_chicken * (chicken_feed_vec * feed_cost_vec)
 
  working_costs_chicken_final <-
    working_hours_chicken * working_hours_costs
```
The chicken have ro be replaced after two years and a varying number of irregular replacements are added.
```{r eval= FALSE}
  chicken_replacement <- vv(var_mean = number_of_chicken,
                            var_CV = 2,
                            n = years)
  
  # setting every second year to zero starting with the first 
  chicken_replacement[] <- chicken_replacement * c(FALSE, TRUE)
  
  chicken_replacement_cost_final <-
    chicken_replacement * chicken_replacement_cost
```
The final income vector for the egg production is created by adding up the varying number of eggs and prices.
```{r eval= FALSE}
  # Income
  
  # Number of eggs per Year
  eggs_per_year <- vv(var_mean = egg_per_hen,
                      var_CV = 2,
                      n = years)
  
  eggs_per_year <- eggs_per_year * number_of_chicken
  
  #
  eggs_price <- vv(
    var_mean = eggs_price,
    var_CV = 5,
    n = years,
    lower_limit = 0.2
  )
  
  eggs_income <- eggs_per_year * eggs_price
  
  chicken_income <-
    eggs_income - (
      maintaining_chicken_mobile_vec + feed_cost_final_vec +
        working_costs_chicken_final + chicken_replacement_cost_final
    )
```

# Calculating CO2
We did not include the income of the certificates to the final model because in every scenario it is also possible that emissions are positive. As CO2 calculation in real life is quite complicated this is just an approximation to get an overview for Woodify as their goal is to sequestrate CO2 on the plot.
We added a variable that calculated the amount of Co2 emmited depending on the produced eggs.
```{r eval= FALSE}
  # Eggs
  
  co2_emmiter_eggs <- (number_of_chicken * egg_per_hen) * co2_per_egg
  
  co2_emmiter_eggs <- co2_emmiter_eggs / kg_per_certificate
```
Then we created a variable that accounts for the soil organic carbon that will increase in time because the land is no longer used to produce crops.
```{r eval= FALSE}
 # SOC Soil organic carbon
  
  total_soc <- soc * (1 - soil_stones)
  
  soc_increase <- total_soc * landuse_increase_soc
  
  annual_soc_increase <- soc_increase / years
  
  annual_soc_increase <- annual_soc_increase / kg_per_certificate
```
The final income that can be generated by selling CO2 certficates for scenario 1 & 4 considering the amount of trees and the soil organic carbon of the years minus the added CO2 by egg production.
```{r eval= FALSE}
# Version 1 and 4
  
  co2_per_year_1_4 <- 70 * kg_per_bush
  
  certifikates_1_4 <- co2_per_year_1_4 / kg_per_certificate
  
  certifikates_1_4 <- certifikates_1_4 + annual_soc_increase - co2_emmiter_eggs
  
  certifikates_1_4_vec <- rep(c(certifikates_1_4), times = years)
  
  certifikates_1_4_final <- Reduce("+", certifikates_1_4_vec)
  
  income_certifikates_1_4_vec <- certifikates_1_4_vec * co2_price_per_ton
  
  income_certifikates_1_4_final <- Reduce("+", income_certifikates_1_4_vec)
```
The final income that can be generated by selling CO2 certficates for scenario 2 & 5 considering the amount of trees and the soil organic carbon of the years minus the added CO2 by egg production.
```{r eval= FALSE}
 # Version 2 and 5
  
  co2_per_year_2_5 <- 200 * kg_per_bush
  
  certifikates_2_5 <- co2_per_year_2_5 / kg_per_certificate
  
  certifikates_2_5 <- certifikates_2_5 + annual_soc_increase - co2_emmiter_eggs
  
  certifikates_2_5_vec <- rep(c(certifikates_2_5), times = years)
  
  certifikates_2_5_final <- Reduce("+", certifikates_2_5_vec)
  
  income_certifikates_2_5_vec <- certifikates_1_4_vec * co2_price_per_ton
  
  income_certifikates_2_5_final <- Reduce("+", income_certifikates_2_5_vec)
```
The final income that can be generated by selling CO2 certficates for scenario 3 considering the amount of trees and the soil organic carbon of the years minus the added CO2 by egg production.
```{r eval= FALSE}
 # Version 3
  
  co2_per_year_3 <- 200 * kg_per_tree
  
  certifikates_3 <- co2_per_year_3 / kg_per_certificate
  
  certifikates_3 <- certifikates_3 + annual_soc_increase - co2_emmiter_eggs
  
  certifikates_3_vec <- rep(c(certifikates_3), times = years)
  
  certifikates_3_final <- Reduce("+", certifikates_3_vec)
  
  income_certifikates_3_vec <- certifikates_1_4_vec * co2_price_per_ton
  
  income_certifikates_3_final <- Reduce("+", income_certifikates_3_vec)
```

# Discounting
As we set the runtime of our model to 30 years it is quite likely that we have to deal with inflation as the money we have right now will probably we worth less later. In our runs we set the `discount_rate` to 3 which can be seen as 3% of inflation over the years. This number can be easily adjusted in the beginning of our code.
For every scenario we used the `discount` function with the same `discount_rate` and added the values for each year into a single number by using the `reduce` function. Here is the example for version 1.
```{r eval= FALSE}
# Version 1
  small_nut_chicken_profit_vec_1 <-
    nut_profit_vec_1 + chicken_income - general_investments_vec + subsidies_vec
  
  small_nut_chicken_profit_vec_1 <- 
    discount(small_nut_chicken_profit_vec_1, discount_rate)
  
  small_nut_chicken_profit_1 <- Reduce("+", small_nut_chicken_profit_vec_1)
```
For scenario 4 we additionally had to account for the smaller number of trees in the truffle production by dividing by the factor 2.8.
```{r eval= FALSE}
 # Version 4
  small_nut_chicken_truffle_profit_vec_4 <-
    nut_profit_vec_1 + chicken_income + (truffle_final_vec_4_5/2.8) - 
    general_investments_vec + subsidies_vec
```
# The Decisions
To compare decisions, it is important to calculate the income of the scenarios minus the baseline to see the actual benefits.
```{r eval= FALSE}
decision_1 <- small_nut_chicken_profit_1 - baseline
  
decision_2 <- big_nut_chicken_profit_2 - baseline
  
decision_3 <- truffle_chicken_profit_3 - baseline

decision_4 <- small_nut_chicken_truffle_profit_4 - baseline
  
decision_5 <- big_nut_chicken_truffle_profit_5 - baseline
```
The last part of our `model_function` is the `return` which stores our results in a list of different vectors that can be later used for visualization.
```{r eval= FALSE}
 return(list(outcome_1 = small_nut_chicken_profit_1,
              outcome_2 = big_nut_chicken_profit_2,
              outcome_3 = truffle_chicken_profit_3,
              outcome_4 = small_nut_chicken_truffle_profit_4,
              outcome_5 = big_nut_chicken_truffle_profit_5,
              outcome_6 = chicken_profit_6,
              baseline = baseline,
              decision_1 = decision_1,
              decision_2 = decision_2,
              decision_3 = decision_3,
              decision_4 = decision_4,
              decision_5 = decision_5,
              d_5_inst_3 = d_5_inst_3,
              certifikates_1_4 = certifikates_1_4_final,
              certifikates_2_5 = certifikates_2_5_final,
              certifikates_3 = certifikates_3_final,
              vec_outcome_1 = small_nut_chicken_profit_vec_1,
              vec_outcome_2 = big_nut_chicken_profit_vec_2,
              vec_outcome_3 = truffle_chicken_profit_vec_3,
              vec_outcome_4 = small_nut_chicken_truffle_profit_vec_4,
              vec_outcome_5 = big_nut_chicken_truffle_profit_vec_5,
              vec_outcome_baseline = baseline_vec,
              co2_egg = co2_emmiter_eggs))
```

# Results

## Explaining Results/Values

Running the model produces a different outputs who are defined in the return list of the `model_function`. In this case it includes the accumulated income values for each scenario for the whole time-period, a vector with annual distribution of income for each scenario as well as different calculated decisions. Additionally the amount of sequestered CO2 is considered as an output.
The raw model-results of each scenario, including the baseline, is shown in the Graph 1. 
On the X-Axis the possible revenue distribution in € is displayed. The Y-Axis displays the probability density how likely one certain amount of revenue is likely. If the Curve for a scenario is wide, it means that the the degree of uncertainty is high, the possible revenue range is large. The smaller the curve is, the scenario is more defined and it is of a higher certainty that the displayed revenue is reached.
The baseline has the smallest curve, which means that this base-scenario is, compared to the other scenarios, well defined. This is because normal crop land is a well known and researched system with comparable few components who affect the income. The more aspects are added to a system, the uncertainty adds up and the distribution curve grows. Also single components with a high uncertainty, such as the truffles, add uncertainty to the whole system. This is also visible in Graph 1, the systems including nuts, chicken and truffle have the widest distribution curve. The very left side of a curve is the chance of getting always the worst part of the range of every input factor. If the  ranges for the input factors are chosen right, this is the point of the lowest possible income or highest possible loss. The very right side is the opposite, always the best part of the range of the input factors occur. So its the maximal possible revenue.
Based on the Curves for every scenario, different decisions can be modeled and conclusions can be drawn. The `decisionSupport` [@luedeling_decisionsupport_2021] Package also allows provides additional in depth analysis tools. They were also used for the evaluation of the results in this chapter.
=======
# Results

## Explaining Results/Values

Running the model produces different outputs who are defined in the return list of the `model_function`. In this case it includes the accumulated income values for each scenario for the whole time-period, a vector with annual distribution of income for each scenario as well as different calculated decisions. Additionally the amount of sequestered CO2 is considered as an output.

From these outputs four different graphs are calculated for each scenario. The first one displays the outcome distribution of the simulated incomes. The income is accumulated over 30 years. On the X-Axis the possible revenue distribution in € is displayed. The Y-Axis displays the probability density how likely a certain amount of income is. If the Curve for a scenario is wide, it means that the degree of uncertainty is high, the possible income range is large. The smaller the curve is, the more is the scenario defined and it is of a higher certainty that a certain income is generated. The more aspects are added to a system, the uncertainty adds up and the distribution curve grows. Also single components with a high uncertainty, such as the truffles, add uncertainty to the whole system. The very left side of a curve is the chance of getting always the worst part of the range of every input factor. If the  ranges for the input factors are chosen right, this is the point of the lowest possible income or highest possible loss. The very right side is the opposite, always the best part of the range of the input factors occur. So its the maximal possible revenue. The truth will most likely lay somewhere in between.
The next graph models the annual cashflow over 30 years. It displays the median as well as the 50% and 90% confidence interval. Here the investment costs in the first year are visible and annual variations are displayed.
The third graph is the Projection to Latent Structures (PLS) analysis.
The fourth graph is the EVPI.

### Baseline

![Result Baseline after 10.000 model runs, From top left to bottom right: Income Distribution accumulated values after 30 years; Annual cashflow with confidence interval; PLS analysis; EVPI analysis](report/baseline.jpeg)



### Results Scenario 1

![Result Scenario 1 after 10.000 model runs, From top left to bottom right: Income Distribution accumulated values after 30 years; Annual cashflow with confidence interval; PLS analysis; EVPI analysis](report/scenario_1.jpeg)

Scenario 1 has the narrowest distribution curve and in the median also the lowest simulated income. Because it uses only 70 hazelnut trees the yield uncertainty is lower than in the bigger plantations with 200 hazelnut trees. And while there is an additional factor, the hay making, this produces such small incomes that it does not widen the distribution curve. Even so the median is the lowest, because of its narrow distribution it is still most likely to produce more income compared to the baseline and is therefor a valid option to choose from. Especially since it is the system with the lowest initial investment costs. 

### Results Scenario 2

![Result Scenario 2 after 10.000 model runs, From top left to bottom right: Income Distribution accumulated values after 30 years; Annual cashflow with confidence interval; PLS analysis; EVPI analysis](report/scenario_2.jpeg)

Scenario 2 has a much wider distribution which extends to the left side, so the median is also higher. This is because here 200 hazelnut trees are planted and the scaling factor makes it more profitable. While the possibility off losses are similar to the first scenario, the possible income is higher. This makes it from a business standpoint a more promising choice. But with more hazelnut bushes the amount of working hours needed to sustain this system is also larger, which needs to be considered by the stakeholders. 

### Results Scenario 3

![Result Scenario 3 after 10.000 model runs, From top left to bottom right: Income Distribution accumulated values after 30 years; Annual cashflow with confidence interval; PLS analysis; EVPI analysis](report/scenario_3.jpeg)

Scenario 3 is the first one using

### Results Scenario 4

![Result Scenario 4 after 10.000 model runs, From top left to bottom right: Income Distribution accumulated values after 30 years; Annual cashflow with confidence interval; PLS analysis; EVPI analysis](report/scenario_4.jpeg)

### Results Scenario 5

![Result Scenario 5 after 10.000 model runs, From top left to bottom right: Income Distribution accumulated values after 30 years; Annual cashflow with confidence interval; PLS analysis; EVPI analysis](report/scenario_5.jpeg)
## Conclusions

### Improvements
How the scenarios finally compare to each other.

Graph 1 shows the simulated distribution of income for the 5 scenarios and the baseline. It shows that most likely every scenario will produce a positive overall income over a period of 30 years. Even so with every scenario there is also a chance of producing an overall loss, most of the curves are in the positive range. But it also shows that most of the scenarios have a very wide range of possible incomes.
To get a better overview over the 5 scenarios, we decided to use another option for plotting. Graph 2 was generated by the `bayesplot`library with the `mcmc_areas()`function. Here, the distribution curve of every scenario is plotted separately. The dark blue line is marking the median of the distribution and the light blue area the 50 percent interval. Now the differences between the scenarios are well visible.

### Personal advise
What scenario we would recommend and why

### Outlook
What could be added to the model: The amount of working hours per system could be acknowledged. This would enable the stakeholder, especially the farmer, to compare each system better with their personal preferences. 
After harvest costs and risks need to be considered in an updated version od the model.
The CO2 simulation can be improved by involving experts and the decision maker woodify.


### Improvements

# References